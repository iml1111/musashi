import React from 'react'

// Define EdgeProps type locally
interface EdgeProps {
  id: string
  sourceX: number
  sourceY: number
  targetX: number
  targetY: number
  sourcePosition?: string
  targetPosition?: string
  style?: React.CSSProperties
  markerEnd?: any
  markerStart?: any
  data?: any
  source: string
  target: string
}

// Simple custom edge component for Reaflow compatibility
export const CustomEdge = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  style = {},
  markerEnd,
  markerStart,
  data,
  source,
  target,
}: EdgeProps) => {
  // Check for self-loop
  const isSelfLoop = source === target
  
  // Check if this is an upward connection (source is below target)
  const isUpward = sourceY > targetY + 20
  
  // Check if nodes are at the same level
  const isSameLevel = Math.abs(sourceY - targetY) < 50 && !isSelfLoop
  
  let edgePath: string
  
  if (isSelfLoop) {
    // Self-loop edge - create a loop to the side
    const loopSize = 80
    const loopDirection = 1 // Always loop to the right
    edgePath = `M ${sourceX},${sourceY} 
                C ${sourceX + loopSize * loopDirection},${sourceY - loopSize} 
                  ${sourceX + loopSize * loopDirection},${sourceY + loopSize} 
                  ${sourceX},${sourceY}`
  } else if (isUpward && !isSameLevel) {
    // For upward connections (cycles), create a smooth curve to the side
    const horizontalGap = Math.abs(sourceX - targetX)
    const verticalGap = Math.abs(sourceY - targetY)
    
    // Determine curve direction based on node positions
    const curveRight = sourceX <= targetX
    
    // Calculate control points for a smooth curve
    const offsetFactor = Math.min(1.5, verticalGap / 200)
    const sideOffset = Math.max(150, Math.min(300, horizontalGap * offsetFactor))
    
    if (curveRight) {
      // Curve to the right side
      const controlX = Math.max(sourceX, targetX) + sideOffset
      const midY = (sourceY + targetY) / 2
      
      edgePath = `M ${sourceX},${sourceY}
                  C ${sourceX + 30},${sourceY}
                    ${controlX},${sourceY - 30}
                    ${controlX},${midY}
                  S ${controlX},${targetY + 30}
                    ${targetX + 30},${targetY}
                  L ${targetX},${targetY}`
    } else {
      // Curve to the left side
      const controlX = Math.min(sourceX, targetX) - sideOffset
      const midY = (sourceY + targetY) / 2
      
      edgePath = `M ${sourceX},${sourceY}
                  C ${sourceX - 30},${sourceY}
                    ${controlX},${sourceY - 30}
                    ${controlX},${midY}
                  S ${controlX},${targetY + 30}
                    ${targetX - 30},${targetY}
                  L ${targetX},${targetY}`
    }
  } else if (isSameLevel) {
    // For connections at the same level, create a gentle arc
    const midX = (sourceX + targetX) / 2
    const offsetY = sourceX < targetX ? 60 : -60
    
    edgePath = `M ${sourceX},${sourceY}
                Q ${midX},${sourceY + offsetY}
                  ${targetX},${targetY}`
  } else {
    // For normal downward connections, use simple bezier curve
    const midY = (sourceY + targetY) / 2
    edgePath = `M ${sourceX},${sourceY}
                C ${sourceX},${midY}
                  ${targetX},${midY}
                  ${targetX},${targetY}`
  }

  // Calculate label position
  const labelX = (sourceX + targetX) / 2
  const labelY = (sourceY + targetY) / 2

  return (
    <g>
      <path
        id={id}
        d={edgePath}
        fill="none"
        style={{
          ...style,
          strokeDasharray: '5 5',
          animation: 'dashdraw 0.5s linear infinite',
          stroke: style?.stroke || '#374151',
          strokeWidth: style?.strokeWidth || 3,
        }}
        markerEnd={markerEnd}
        markerStart={markerStart}
      />
      {data?.sourceOutput && (
        <foreignObject
          x={labelX - 40}
          y={labelY - 15}
          width={80}
          height={30}
        >
          <div
            style={{
              background: '#ffffff',
              border: '1px solid #374151',
              borderRadius: '4px',
              padding: '4px 8px',
              fontSize: '11px',
              fontWeight: 600,
              textAlign: 'center',
              cursor: 'pointer',
              userSelect: 'none',
            }}
            onClick={(e) => {
              e.stopPropagation()
              if (data.onLabelClick) {
                data.onLabelClick(e, id, data.sourceOutput)
              }
            }}
          >
            {data.sourceOutput}
          </div>
        </foreignObject>
      )}
    </g>
  )
}

// Edge types object for compatibility
export const edgeTypes = {
  custom: CustomEdge,
  smoothstep: CustomEdge,
}

// Add CSS animation for dashed edges
const style = document.createElement('style')
style.textContent = `
  @keyframes dashdraw {
    from {
      stroke-dashoffset: 10;
    }
    to {
      stroke-dashoffset: 0;
    }
  }
`
document.head.appendChild(style)